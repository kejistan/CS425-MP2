Sean Nicolay (nicolay2)
Mike Crawford (crawfor9)

The design of our distributed hash table, based on the Chord system, is relatively simple. Adding nodes is accomplished through the standard finger table message passing system. When a node requests to be added to the system whichever node handles the request sends a message around the ring with the new node's id as the destination. This ensures that the request will reach the node the will be the next node after the new node. If this node is not currently adding a node into the ring it will take over comminications with the new node. Otherwise it will buffer the message until it has finished adding the node it is currently handling. This serialization of concurrent adds to the same node is done to ensure consistent state and does not significantly impact the ability of the ring as a whole to concurrently add nodes. When a node is being added a message is sent from the handler node to inform the new node of it's position in the ring by informing it of the nodes that are next and previous to it. The handler also notifies the previous node to update it's next entry to point to the new node. The new node will wait until recieving confirmation messages from its new next and previous nodes before requesting to transfer hash table entries from it's next node. The next node will then send transfers serially to the new node until it has transferred every entry the new node now ``owns''. Upon confirmation of the last transfer the handler node replies to the new node that the transfer is finished and allows itself to handle any new add node requests. During this process the new node will buffer any requests that are destined for itself until it recieves the transfer finished message. At that point it will initialize it's finger table by sending node lookup requests and will begin processing queued messages.
Updating a node's finger table is accomplished by sending a message around the ring using only the next node entries until it reaches the node addressed in the message, this ensures that stale finger table data will not cause loops in searching to update a finger table. When a node recieves a lookup request that contains an id which it ``owns'' it replies back directly to the requester with the information required to send a message to itself. If during the course of handling messages a node recieves a message destined for another node that is between the source and itself (the message has been passed too far) it replies directly back to the last node to handle the message informing it to update its finger table. It also passes the message on to the next closest node it knows of.
When a file add, find, or delete request is recieved the message contains the key of the requested file which is then used to insert, find or delete in a local hash table. If the file is found a normal acknowledgement message is replied directly to the original requestor, otherwise a file not found message is replied. The local nodes never handle the actual file names for files and only process the sha1 hash as a key. Modifying the hash table to use the original filename as the unique id would be possible with minimal work but operating on the sha1 hash keeps the messages consistent and has a very low probability of collisions. This also simplifies the node processes as they do not need to calculate sha1 hashes themselves. The local hash table uses separate chaining to handle internal hash collisions.
Quit is implemented as a simple ring message, the first node to recieve a quit message sends an internal quit message to it's next node which proceeds to send the same message to its next node before quitting. The original reciever will eventually recieve a quit message once every node has quit and will thusly quit as normal. This enables the system to have no odd special cases and requires a minimal number of messages to be passed in order to cause every node to quit cleanly. Nodes that are in the process of being added forward their quit messages to their new nodes as well as a precausion to ensure that new nodes which might not be anyone's next node are quit as well.
The project was split up such that Sean worked on most of the hash table and related functionality, while Mike implemented the majority of the node adding functions. Finger table related functions were implemented by both of us.
